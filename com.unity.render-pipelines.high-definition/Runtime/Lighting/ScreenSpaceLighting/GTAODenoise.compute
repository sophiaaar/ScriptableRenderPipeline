#include "GTAOCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

#pragma kernel GTAODenoise_Spatial SPATIAL
#pragma kernel GTAODenoise_Temporal                     TEMPORAL_DENOISE_KERNEL_NAME=GTAODenoise_Temporal         TEMPORAL  HALF_RES
#pragma kernel GTAODenoise_Temporal_FullRes             TEMPORAL_DENOISE_KERNEL_NAME=GTAODenoise_Temporal_FullRes TEMPORAL  FULL_RES


#pragma enable_d3d11_debug_symbols

#define BLUR_TYPE 0 // this is for testing, no bilateral

RW_TEXTURE2D_X(float3, _BentNormalsTexture);

TEXTURE2D_X_UINT(_AOPackedData);

#ifdef SPATIAL

RW_TEXTURE2D_X(uint, _AOPackedBlurred);

float BilateralWeight(float sampleDepth, float centralDepth)
{
    float delta = abs(sampleDepth - centralDepth);
    return delta < centralDepth * 0.31;// TODO_FCC. actual bilateral weighting here.
}

float Blur(float2 centralPos, out float centralDepth)
{
    float2 temporalOffset = 0;// (_FrameCount & 1) == 0 ? float2(-1.0f, 1.0f) : float2(1.0f, -1.0f);

    uint4 data_12_15 = GATHER_TEXTURE2D_X(_AOPackedData, s_linear_clamp_sampler, (centralPos + float2(0.0f, 0.0f) + temporalOffset)  * _AOBufferSize.zw);


    float4 UnpackedAOs, UnpackedDepths;
    UnpackGatheredData(data_12_15, UnpackedAOs, UnpackedDepths);
    centralDepth = UnpackedDepths.y;


    float total = UnpackedAOs.y;
    float totalWeight = 1;

    // This manual unrolling is horrible looking, but I found it hard to please the PS4 compiler otherwise. TODO: Make this nicer. 

    // First set of gathered data.
    float weight = BilateralWeight(UnpackedDepths.x, centralDepth);
    total += weight * UnpackedAOs.x;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.z, centralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.w, centralDepth);
    total += weight * UnpackedAOs.w;
    totalWeight += weight;

    // Second set of gathered data.
    uint4 data_8_11 = GATHER_TEXTURE2D_X(_AOPackedData, s_linear_clamp_sampler, (centralPos + float2(-2.0f, 0.0f) + temporalOffset)  * _AOBufferSize.zw);
    UnpackGatheredData(data_8_11, UnpackedAOs, UnpackedDepths);

    weight = BilateralWeight(UnpackedDepths.x, centralDepth);
    total += weight * UnpackedAOs.x;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.y, centralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.z, centralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.w, centralDepth);
    total += weight * UnpackedAOs.w;
    totalWeight += weight;


    // Third set of gathered data.
    uint4 data_4_7 = GATHER_TEXTURE2D_X(_AOPackedData, s_linear_clamp_sampler, (centralPos + float2(0.0f, 2.0f) + temporalOffset)  * _AOBufferSize.zw);
    UnpackGatheredData(data_4_7, UnpackedAOs, UnpackedDepths);

    weight = BilateralWeight(UnpackedDepths.x, centralDepth);
    total += weight * UnpackedAOs.x;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.y, centralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.z, centralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.w, centralDepth);
    total += weight * UnpackedAOs.w;
    totalWeight += weight;

    // Fourth set of gathered data.
    uint4 data_0_3 = GATHER_TEXTURE2D_X(_AOPackedData, s_linear_clamp_sampler, (centralPos + float2(-2.0f, 2.0f) + temporalOffset)  * _AOBufferSize.zw);
    UnpackGatheredData(data_0_3, UnpackedAOs, UnpackedDepths);

    weight = BilateralWeight(UnpackedDepths.x, centralDepth);
    total += weight * UnpackedAOs.x;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.y, centralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.z, centralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.w, centralDepth);
    total += weight * UnpackedAOs.w;
    totalWeight += weight;


    total /= totalWeight;
    return total;
}

[numthreads(8, 8, 1)]
void GTAODenoise_Spatial(uint3 dispatchThreadId : SV_DispatchThreadID)
{

    uint currData = _AOPackedData[COORD_TEXTURE2D_X(dispatchThreadId.xy)];

    float centralDepth;
    float final = Blur(dispatchThreadId.xy, centralDepth);

    _AOPackedBlurred[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = PackAOOutput(final, centralDepth);
}
#endif


#ifdef TEMPORAL

RW_TEXTURE2D_X(float, _AOOutputHistory);

TEXTURE2D_X_UINT(_AOPackedBlurred);
TEXTURE2D_X(_AOPackedHistory);



float3 FetchAO(float2 coords, float2 offset, float2 scale)
{
    float2 uv = (coords + offset * _AOBufferSize.zw) * scale;
    uint data = LOAD_TEXTURE2D_X(_AOPackedBlurred, uv * _AOBufferSize.xy).x;
    float AO, depth;
    UnpackData(data, AO, depth);
    return AO;
}


#if UNITY_REVERSED_Z
#define COMPARE_DEPTH(a, b) step(b, a)
#else
#define COMPARE_DEPTH(a, b) step(a, b)
#endif


float2 GetClosestFragment(float2 positionSS)
{
    float center = LoadCameraDepth(positionSS);
    float nw = LoadCameraDepth(positionSS + int2(-1, -1));
    float ne = LoadCameraDepth(positionSS + int2(1, -1));
    float sw = LoadCameraDepth(positionSS + int2(-1, 1));
    float se = LoadCameraDepth(positionSS + int2(1, 1));

    float4 neighborhood = float4(nw, ne, sw, se);

    float3 closest = float3(0.0, 0.0, center);
    closest = lerp(closest, float3(-1.0, -1.0, neighborhood.x), COMPARE_DEPTH(neighborhood.x, closest.z));
    closest = lerp(closest, float3(1.0, -1.0, neighborhood.y), COMPARE_DEPTH(neighborhood.y, closest.z));
    closest = lerp(closest, float3(-1.0, 1.0, neighborhood.z), COMPARE_DEPTH(neighborhood.z, closest.z));
    closest = lerp(closest, float3(1.0, 1.0, neighborhood.w), COMPARE_DEPTH(neighborhood.w, closest.z));

    return positionSS + closest.xy;
}

float3 ClipToAABB(float color, float minimum, float maximum)
{
    // note: only clips towards aabb center (but fast!)
    float center = 0.5 * (maximum + minimum);
    float extents = 0.5 * (maximum - minimum);

    // This is actually `distance`, however the keyword is reserved
    float offset = color - center;

    float ts = abs(extents) / max(abs(offset), 1e-4);
    return center + offset * saturate(ts);
}


RW_TEXTURE2D_X(float4, _AODebug);


#if HALF_RES
RW_TEXTURE2D_X(uint, _OcclusionTexture);
#else
RW_TEXTURE2D_X(float, _OcclusionTexture);
#endif

float4 GetBilinearWeights(float2 uv)
{
    return 0.25f;
}

[numthreads(8, 8, 1)]
void TEMPORAL_DENOISE_KERNEL_NAME(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    float2 uv = (dispatchThreadId.xy + 0.5f) * _AOBufferSize.zw/*- jitter*/;

    uint currFrameData = _AOPackedBlurred[COORD_TEXTURE2D_X((uv)* _AOBufferSize.xy)];
    float currDepth, currAO;
    UnpackData(currFrameData, currAO, currDepth);

    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), _ScreenSize.zw, uint2(8, 8));

    float2 closest = posInputs.positionSS * (1 + _AOBaseResMip);// GetClosestFragment(posInputs.positionSS * (1 + _AOBaseResMip));
    float2 motionVector;
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, closest), motionVector);
    float motionVecLength = length(motionVector);

    float2 prevFrameNDC = uv - motionVector;

    float prevAO = _AOPackedHistory[COORD_TEXTURE2D_X((prevFrameNDC) * _AOBufferSize.xy)]; //SAMPLE_TEXTURE2D_X_LOD(_AOPackedHistory, s_linear_clamp_sampler, prevFrameNDC, 0).x;
    //float prevAO, prevdepth;
    //UnpackData(prevData, prevAO, prevdepth);


    // Gather history
    //uint4 historyData = GATHER_TEXTURE2D_X(_AOPackedHistory, s_linear_clamp_sampler, prevFrameNDC);
    //float4 prevAOs, prevDepths;
    //UnpackGatheredData(historyData, prevAOs, prevDepths);

    // Gather curr
    uint4 currDatas = GATHER_TEXTURE2D_X(_AOPackedBlurred, s_linear_clamp_sampler, uv);
    float4 currAOs, currDepths;
    UnpackGatheredData(currDatas, currAOs, currDepths);


    //float scale = 100.0f;
    //float history = 0.0f;
    //float4 bw = 0;
    //for (int i = 0; i < 4; ++i)
    //{
    //    float bilateralWeight = saturate(1.0f - scale * (currDepth - prevDepths[i]));
    //    bw[i] = bilateralWeight;
    //    history += 0.25f * lerp(currAO, prevAOs[i], bilateralWeight);
    //}

    float nudgy = 0.05;
  //  float nudge = lerp(4.0, 0.25, saturate(motionVecLength * 100.0)) * abs(averageLuma - colorLuma);

    float minAO = min(Min3(currAOs.x, currAOs.y, currAOs.z), currAOs.w) - nudgy;
    float maxAO = max(Max3(currAOs.x, currAOs.y, currAOs.z), currAOs.w) + nudgy;

    prevAO = ClipToAABB(prevAO, minAO, maxAO);

    float newAO = (lerp(currAO, prevAO, 0.9f));


    _AOOutputHistory[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = newAO;

#ifdef HALF_RES
    // The conversion and the pow happens in upsample phase.
    _OcclusionTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = PackAOOutput(newAO, currDepths.y);
#else
    _OcclusionTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = 1.0f - pow(newAO, _AOIntensity);
#endif
}
#endif


