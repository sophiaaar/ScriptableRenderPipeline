#include "GTAOCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

#pragma kernel GTAOMain
#pragma enable_d3d11_debug_symbols

// --------------------------------------------
// Options
// --------------------------------------------

// Integral type 
#define INTEGRAL_UNIFORM 0
#define INTEGRAL_COSINE 1
#define INTEGRAL_TYPE INTEGRAL_COSINE

// Noise options
#define TEMPORAL_ROTATION 1
#define ENABLE_TEMPORAL_OFFSET 1

// Normal fetching options
#define NORMAL_FROM_GBUFFER 1
#define NORMAL_COMPUTATION NORMAL_FROM_GBUFFER

#define THE_VERSION_LAURENT_LIKES 1

// --------------------------------------------
// Integration functions
// --------------------------------------------

float IntegrateArcUniform(float horizon1, float horizon2)
{
    return (1.0f - cos(horizon1) + (1.0f - cos(horizon2)));
}

float IntegrateArcCosWeighted(float horzion1, float horizon2, float n, float cosN)
{
    float h1 = horzion1 * 2.0f; 
    float h2 = horizon2 * 2.0f;
    float sinN = sin(n);
    return 0.25f * ((-cos(h1 - n) + cosN + h1 * sinN) + (-cos(h2 - n) + cosN + h2 * sinN));
}

float UpdateHorizon(float maxH, float candidateH, float distSq)
{
    float falloff = saturate((1.0f - (distSq * _AOInvRadiusSq)));    // TODO_FCC: Check this, maybe without the pow is enough.

    return (candidateH > maxH) ? lerp(maxH, candidateH, falloff) : maxH;        // TODO_FCC: Thickness heuristic here.
}

// --------------------------------------------
// Noisy functions
// --------------------------------------------

float2 GetDirection(uint2 positionSS)
{
    // Spatial distribution 
    float noise = (1.0 / 16.0) * ((((positionSS.x + positionSS.y) & 0x3) << 2) +
        // Note: in the original presentation, this has a bug as the following needs to be positionSS.y and not positionSS.x
        (positionSS.y & 0x3)) * PI;
    

#if TEMPORAL_ROTATION
    // Temporal rotations
    float rotations[] = { 60.0f, 300.0f, 180.0f, 240.0f, 120.0f, 0.0f };
    float rotation = (rotations[_AOTemporalRotationIdx] / 360.0f);

    noise += rotation; 
#endif

    float2 dir = float2(cos(noise), sin(noise));

    return dir;
}

// --------------------------------------------
// Get sample start offset
// --------------------------------------------

float GetOffset(uint2 positionSS)
{
    // Spatial offset
    float offset = 0.25f * ((positionSS.y - positionSS.x) & 0x3);

    // Temporal offset
#if ENABLE_TEMPORAL_OFFSET
    float offsets[] = { 0.0f, 0.5f, 0.25f, 0.75f };
    offset += offsets[_AOTemporalOffsetIdx];
#endif
    return frac(offset);
}

// --------------------------------------------
// Input generation functions
// --------------------------------------------

float3 GetPositionVS(float2 positionSS, out float depth)
{
    depth = GetDepth(positionSS);
    float linearDepth = LinearEyeDepth(depth, _ZBufferParams);
    return float3((positionSS * _AODepthToViewParams.xy - _AODepthToViewParams.zw) * linearDepth, linearDepth);
}

float3 GetNormalVS(float4 normalBufferData)
{
    NormalData normalData;
    DecodeFromNormalBuffer(normalBufferData, 0, normalData);
    float3 normalVS = normalize(mul((float3x3)UNITY_MATRIX_V, normalData.normalWS));
    return float3(normalVS.xy, -normalVS.z);
}

// --------------------------------------------
// Kernel
// --------------------------------------------

float HorizonLoop(float3 positionVS, float3 V, float2 rayStart, float2 rayDir, float rayOffset, float rayStep, int mipModifier)
{
    float maxHorizon = -1;
    float t = rayOffset * rayStep + rayStep;

    for (int i = 0; i < _AOStepCount; i++)
    {
        float2 samplePos = min(rayStart + t * rayDir, _AOBufferSize.xy - 1);

        // Find horizons at these steps:
        float sampleDepth; 
        float3 samplePosVS = GetPositionVS(samplePos.xy, sampleDepth);

        float3 deltaPos = samplePosVS - positionVS;
        float deltaLenSq = dot(deltaPos, deltaPos);

        float currHorizon = dot(deltaPos, V) * rsqrt(deltaLenSq);
        maxHorizon = UpdateHorizon(maxHorizon, currHorizon, deltaLenSq);

        t += rayStep;
    }

    return maxHorizon;
}

RW_TEXTURE2D_X(float, _OcclusionTexture);
RW_TEXTURE2D_X(float3, _BentNormalsTexture);
RW_TEXTURE2D_X(uint, _AOPackedData);

[numthreads(8,8,1)]
void GTAOMain (uint3 dispatchThreadId : SV_DispatchThreadID)
{
    // Read buffers as early as possible.
    float currDepth;
    float3 positionVS = GetPositionVS(dispatchThreadId.xy, currDepth);
    float4 normalBufferData = LOAD_TEXTURE2D_X(_NormalBufferTexture, dispatchThreadId.xy * (_AOBaseResMip + 1));


    float2 dir = GetDirection(dispatchThreadId.xy);
    float offset = GetOffset(dispatchThreadId.xy);

    float2 rayStart = dispatchThreadId.xy;

    float3 V = normalize(-positionVS);
    float fovCorrectedradiusSS =  clamp(_AORadius * saturate(max(1, positionVS.z - 2) * 1) * _AOFOVCorrection * rcp(positionVS.z), _AOStepCount, 128);
    float step = fovCorrectedradiusSS * _AOInvStepCountPlusOne;


    // Find horizons 
    float2 maxHorizons;
    maxHorizons.y = HorizonLoop(positionVS, V, rayStart, -dir, offset, step, 0);
    maxHorizons.x = HorizonLoop(positionVS, V, rayStart, dir, offset, step, 0);

    // We now can transform normal data into normal in view space (latency from read should have been hidden as much as possible)
    float3 normalVS = GetNormalVS(normalBufferData);

    // Integrate horizons 
    float3 sliceN =  normalize(cross(float3(dir.xy, 0.0f), V.xyz));
    float3 projN = normalVS - sliceN * dot(normalVS, sliceN);
    float projNLen = length(projN);
    float cosN = dot(projN / projNLen, V);

    float3 T = cross(V, sliceN);
    float n = -sign(dot(projN, T)) * GTAOFastAcos(cosN);

    // Now we find the actual horizon angles
    maxHorizons.x = -GTAOFastAcos(maxHorizons.x);
    maxHorizons.y = GTAOFastAcos(maxHorizons.y);
    maxHorizons.x = n + max(maxHorizons.x - n, -HALF_PI);
    maxHorizons.y = n + min(maxHorizons.y - n, HALF_PI);

#if INTEGRAL_TYPE == INTEGRAL_COSINE
#if THE_VERSION_LAURENT_LIKES
    float integral = 1 * IntegrateArcCosWeighted(maxHorizons.x, maxHorizons.y, n, cosN);
#else
    float integral = projNLen * IntegrateArcCosWeighted(maxHorizons.x, maxHorizons.y, n, cosN);
#endif
#elif INTEGRAL_TYPE == INTEGRAL_UNIFORM
    float integral = projNLen * IntegrateArcUniform(maxHorizons.x, maxHorizons.y);
#endif 

    //// Bent normals stuff
    //float bentNormalAngle = (maxHorizons.x + maxHorizons.y) * 0.5f;
    //_BentNormalsTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = abs(_AOMipOffset - mipOffset).xyxy;

    if (currDepth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        integral = 1;
    }

    _AOPackedData[COORD_TEXTURE2D_X(dispatchThreadId.xy)] =  PackAOOutput(saturate(integral), currDepth);
} 
